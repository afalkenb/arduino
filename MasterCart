***********************
This code is for the master cart. 
The master cart houses the master arduino. 
This code is a copy of the average cart's code with the ADDITION of 
     telling all carts to begin the protocol AND 
     regulating the heights of all carts. 
*************************
  
#include <LIDARLite_v4LED.h>
#include <SparkFun_TB6612.h>
#include <Wire.h>

unsigned long currentTime, previousTime;
double elapsedTime;
double error;
double lastError;
double input, output, setPoint;
double cumError, rateError;
double proximity; //proximity sensor
double tension; //tension sensor reading
double distance; //input height
double encoderL; //Left Encoder Reading
double encoderR; //Right Encoder Reading
int oldtime;
int newtime;
double pastencoderLpos;
double pastencoderRpos;
double prox_top;
double prox_bot;
double proximity_top;
double proximity_bot;
double encoder_L;
double encoder_R;
double ldr_L;
double ldr_R;
int start;
int firsttime;

void setup() {
  // put your setup code here, to run once:
  
  //I2C Master Setup
  Wire.begin();
  Serial.begin(9600);
  
  //H-bridge Setup
  setPointL = motor1.drive(100);
  setPointR = motor2.drive(100);
  pastencoderLpos = 0;
  pastencoderRpos = 0;
  oldtime = 0;
  
  //Initialize Pins
  prox_top= 13;
  prox_bot = 12;
  ldr_L = 14;
  ldr_R = 16;
  encoder_L = 46;
  encoder_R = 48;
  tension = 31; 
  start = 0;
  
  pinMode(prox_top, INPUT)
  pinMode(prox_bot, INPUT)
  pinMode(tension, INPUT)
  pinMode(encoder_L, INPUT)
  pinMode(encoder_R, INPUT
  pinMode(ldr_L, INPUT)
  pinMode(ldr_R, INPUT)

}

void loop() {
  // put your main code here, to run repeatedl
  
  //If The Program Just Started, Start the 15 Average Carts
  if (firsttime == 1)
  {
     begin(); 
     firsttime = 0;
  }
  
  //Read Encoder and get Speed
  encoder_L = analogRead(encoder_L) //reads left encoder
  encoder_R = analogRead(encoder_R) //reads right encoder
  encoder_L = encoderL/24.446; //converts encoder count to distance in inches
  encoder_R = encoderR/24.446; //converts encoder count to distance in inches
  newtime = millis();
  speedL = (encoder_L - pastencoderLpos)*1000 / (newtime - oldtime); //calculated speed in in/s
  speedR = (encoder_R - pastencoderRpos)*1000 / (newtime - oldtime); //calculated speed in in/s
  oldtime = newtime;
  pastencoderLpos = encoder_L;
  pastencoderRpos = encoder_R;
  
  //Read Other Sensors
  proximity_top = analogRead(proximity_top) //reads proximity sensor
  ldr_L = myLidarLite.readDistance() //reads relation to each cart
  ldr_R = myLidarLite.readDistance() //reads relation to each cart
  
  distance = 1; //device should stop when it is 1m from the top of tower
  if (prox_top > distance)
  // checks to see if the device is close to the top of the turbine
  {
  
    destens = 1975; 
    if (tension > destens)
    {
       tightenFunction();
    }
   else if (tension < destens)
   {
        loosenFunction();
   }
   
    if (ldr_L < distance)
    {
      output_left = left(Motor left, Motor right, int speed);
    }
    else if (ldr_R < distance)
    {
      output_right = right(Motor left, Motor right, int speed);
    }
    else
    {
      output_left = climbingFunction_left(proximity, encoder_distL, speedL);
      output_right = climbingFunction_right(proximity, encoder_distR, speedR):
    }
    analogWrite(3, output_left);
    analogWrite(5, output_right);
  }
  else if (proximity <= distance)
  {
      serial.printIn("spraydown.ino")
  }
}

double climbingFunction_left(double proximity, double encoderL, double speedL){
    if (proximity > distance) //if the proximity sensor doesn't detect constraint proceed
    {
      input = speedL;
      output = computePID_left(input);
      return output
    }
    else
    {
      return 0
    }
}

double computePID_left(double inp){
  currentTime = millis();
  elapsedTime = (double)(currentTime - previousTime);
  error = setPointL - inp;
  cumError += error*elapsedTime;
  rateError = (error-lastError)/elapsedTime;

  double out = kp*error + ki*cumError + kd*rateError;
  lastError = error;
  previousTime = currentTime;

  return out;
}

double climbingFunction_right(double proximity, double encoderR, double speedR){
    if (proximity > distance)
    {
      input = speedR;
      output = computePID_left(input);
      return output
    }
    else
    {
      return 0
    }
}

double computePID_right(double inp){
  currentTime = millis();
  elapsedTime = (double)(currentTime - previousTime);
  error = setPointR - inp;
  cumError += error*elapsedTime;
  rateError = (error-lastError)/elapsedTime;

  double out = kp*error + ki*cumError + kd*rateError;
  lastError = error;
  previousTime = currentTime;

  return out;
}

void begin() {

  //Tighten First 
  tightenFunction()
  
  start = 1;
  //Execute Code that climbs and controls for the 14 AverageCarts
  AverageCart1(int start);
  AverageCart2(int start);
  AverageCart3(int start);
  AverageCart4(int start);
  AverageCart5(int start);
  AverageCart6(int start);
  AverageCart7(int start);
  AverageCart8(int start);
  AverageCart9(int start);
  AverageCart20(int start);
  AverageCart11(int start);
  AverageCart12(int start);
  AverageCart13(int start);
  AverageCart14(int start);
  AverageCart15(int start);
  
  //Loosen Here
  loosenFunction()
  
}


double tightenFunction{
     //Speaking with Prof. Bae About These Issues
}

double loosenFunction{
     //Speaking with Prof. Bae About These Issues
}

